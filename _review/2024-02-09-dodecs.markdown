---
layout: post
title:  "Like Playing 4D Chess"
date:   2024-02-09 07:38:00 +0100
categories: "tilemesh"
---

<p align="center">
  <img src="/Pictures/Post_2/N_from_P.svg" height=400px alt="Ni from Phi"/>
</p>

<ul>
<li>Back to the <a href="/topics/tiles">Tiles</a> topic index.</li>
<li><a href="https://github.com/Duncuiad/MovingFrames/blob/main/OpenGLPG/Core/Dodec.h">Dodec</a> on GitHub <svg class="svg-icon"><use xlink:href="{{ '/assets/minima-social-icons.svg#github' | relative_url }}"></use></svg> </li>
</ul>

In the introductory post to the *Tiles* section, we saw how to generate a square-triangle tiling of the plane. At the end of that post, I called your attention to a handful of questions that relate to how this generation can best be implemented. I'll recap the first two here, so that it will be easier to keep them in mind as you read the post.
- When an edge gets split in two, we use the edge's vertices' positions to calculate the middle vertex's position on the plane. Every time this happens, the numerical errors get worse. 
- One defining property of regular grids, like a checkerboard pattern, is that each vertex is identified by its coordinates on the grid. For example, we can take the point $(78, -172)$ and immediately know two things: that it is indeed a vertex in the grid, and that its neighbours are exactly the vertices $(77, -172)$, $(79, -172)$, $(78, -173)$ and $(78, -171)$, respectively to the west, the east, the south and the north of the original point. This doesn't work on a generic polygonal mesh, like ours definitely is. Or is it?

In this post, we'll build a framework that will allow us to solve both issues at once. It's going to be a little more mathematical than the previous post, but it is by no means addressed to an audience with a mathematical background beyond high-school maths. I'll only ask you to dive into this armed with your best geometric intuition and I will try my best to make the best use of it.

<h2>1. What are Coordinates?</h2>

Let's begin in the world where things go smoothly: regular grids. On a nice and square grid, we're perfectly used to get our bearings by plopping down an arbitrary point, which we call the *origin*. To know where we are, we then simply determine how many steps east-west and how many steps north-south we happen to be with respect to said special point. Which means that we will be given some information of the kind "*17 steps west and 92 north!*", which we promptly translate to the pair of numbers $(-17,92)$ as soon as we decide that our frame of reference will be positively oriented towards the north and the east. We call these numbers *coordinates*.

On a grid though, these are not just *any* coordinates. They are *integer* coordinates! And that's very important: no fractional move allowed in chess, no fractional block placing in Minecraft or Terraria[^1]. In all the sick variations and sad excuses for a grid that we'll see later, this point will never cease to be the most critical. We need those numbers to be *integers*.

Now watch me as I put a *complex number* in a post which I said would only contain some simple high-school maths:

<p align="center">
  <img src="/Pictures/Post_2/Square_Grid.svg" height=400px alt="Square Grid"/>
  <p class="post-meta" align="center">Coordinates on a square grid</p>
</p>

Indulge me as I ask you to notice how the weird part in this picture is not the $i$, but the $1$. Here $i$ is just saying "*step to the north*". We might as well have called the point '$3e+2n$', for "*three steps to the* $e$*ast and two to the* $n$*orth*". $e$ and $n$ could be any direction, by the way: in a different context, they could have been any two vectors[^vector] we found useful for orienting ourselves. For some reason[^2], though, the east is always implicit.

So far so good: we have two red basic steps, $1$ and $i$, and some numbers that tell us how many of the red steps to take: $3$ and $2$  respectively. That's it for square grids, they have nothing more to say. There are two different directions, so two numbers. Let's move on to triangular grids. They have three different directions ($0^\circ$, $120^\circ$, $240^\circ$) so three numbers to describe a point. Right? *Right*? Nope! Take a look at this:

<p align="center">
  <img src="/Pictures/Post_2/Triangular_Grid.gif" alt="Triangular Grid"/>
  <p class="post-meta" align="center">Coordinates on a triangular grid</p>
</p>

First of all, let's clarify a couple of things. Yes, we have three different directions: their names are $1$, $\zeta$ and $\zeta^2$. If you're not familiar with multiplying complex numbers, don't worry. You can take them simply as three symbols, each corresponding to a different vector. The picture shows a point, circled in black, and various ways of reaching it by stepping along the three red vectors.

You might say: of course there are multiple ways to reach the same point. For example, in the square grid, taking a step east, then north, then east, then north, then east again is a different way to reach $3+2i$ than taking three steps east followed by two steps north. You'd be right of course, but let me impose stricter rules to this game:

- You can't backtrack
- Choose a fixed order for the separate movement phases, each of them corresponding to one of the red steps. For example, $1 \longrightarrow i$ or $1 \longrightarrow \zeta \longrightarrow \zeta^2$. You can't split steps along the same direction across different phases. So doing north, then east, then north again is not allowed.

With these rules in place, playing on the square grid becomes very boring. There is but one way to get anywhere. But on the triangular grid, well... take another look at the picture: the rules are holding up. And there are many more paths not shown in the picture that would still satisfy those rules. So what's different? As you probably guessed, the issue is that yes, the directions are three, but they are not *independent*. You can obtain any of the three from the other two[^3]: $\zeta^2$ can be reached by going against $1$ once and then taking one step against $\zeta$. In formulas, $\zeta^2=-1-\zeta$. Of course, there's nothing more fundamental about $\zeta$ and $1$ than $\zeta^2$: we have $\zeta=-1-\zeta^2$ and even $1$ is just $1=-\zeta-\zeta^2$.

We say that each of the collections $\left\\{1, \zeta \right\\}$, $\left\\{1, \zeta^2 \right\\} $ and $\left\\{\zeta,\zeta^2\right\\}$ is a *basis*. For a collection of vectors to be a basis, it needs to satisfy two properties at the same time. As we have seen, the vectors need to be independent, which makes it so we're not including *more* vectors *than are necessary*. But to make up a basis, they also need to be *enough*, in that any point of the grid must be reachable by taking an integer number of steps along those vectors. For example, the collection $\left\\{1, 2\zeta \right\\}$ is made of independent vectors but it is not a basis of the triangular grid, because the point $\zeta$ can't be reached[^5].

What the picture is saying, then, is that each basis assigns *different coordinates* to the same point. Which of the possible bases we use is not important. What we need to keep in mind, rather, is that coordinates only have meaning in relation to one specific basis.

<h2>2. Turning Coordinates into Positions</h2>

Clarifying what coordinates are and how they relate to bases is the key to correctly framing the second of the questions we set out to answer. It also helps in seeing how the two questions are related. 

First of all, if you know the position of the elements of a basis on the plane, meaning their real-number $x$ and $y$ coordinates, then it's easy to calculate the position of any point reachable by taking steps along the basis elements. To get the point's $x$ coordinate, you multiply the $x$ coordinates of each basis vector with the integer coordinate of the point that corresponds to that basis vector, then you add them all together. Do the same for the $y$ coordinate and you get the position of the point on the plane.

Let's do an example with a point $p$ that has coordinates $(-5,-12)$ with respect to the basis $\left\\{\zeta,\zeta^2\right\\}$. On the plane, the real coordinates of the basis vectors are $\zeta=\left(-\frac{1}{2},\frac{\sqrt{3}}{2} \right)$, $\zeta=\left(-\frac{1}{2},-\frac{\sqrt{3}}{2} \right)$. Then $p = (x_p,y_p)$, where

$$
\begin{array}{lll}
x_p = \left(-5\right) \left(-\frac{1}{2}\right) + \left(-12\right) \left(-\frac{1}{2}\right) && = \frac{17}{2} && = 8.5 \\
y_p = \left(-5\right) \left(\frac{\sqrt{3}}{2}\right) + \left(-12\right) \left(-\frac{\sqrt{3}}{2}\right) && = \frac{7 \sqrt{3}}{2} &&\approx 6.06217
\end{array}
$$

With this in mind, it follows that we can avoid progagating numerical errors in the calculation of vertices' positions, and is so doing fix the problem posed by the first question, if:

- We can assign to each vertex of the grid some integer coordinates with respect to some basis (that's just answering the second question!)
- We can obtain the integer coordinates of the middle vertex by only using the integer coordinates of an edge's endpoints.

<h2>3. Finding the 'middle point' of an edge</h2>

Let's see how we would generally set out to find the point over which an edge splits when a deflation rule is applied (when talking about a 'middle point', I'm not referring to the point halfway between an edge's vertices). The simplest of them all is the point constructed on the edge that goes from $0$ to $1$ (the order matters). Let's call this point $\nu$ (pronounced 'nee' or 'noo'). As said in the last post, it's a point that makes an angle of $15^\circ$ counterclockwise with the $x$ axis and whose distance from $0$ is $\frac{1}{2} \left( \sqrt{6} - \sqrt{2} \right)$. You can check that its horizontal real coordinate is exactly $\frac{1}{2}$.

With $\nu$, it's easy generate all other middle points by scale, rotation, and translation. This is how it's done on the complex plane:

<p align="center">
  <img src="/Pictures/Post_2/Middle_Point.gif" alt="Middle Point"/>
  <p class="post-meta" align="center">Bringing $\nu$ to a different edge</p>
</p>

By rotating and scaling $\nu$ by a factor of $q-p$ and then translating it by $p$, $\nu$ is taken from the edge $0$-$1$ to an arbitrary edge $p$-$q$.

For any two points $p$ and $q$, this formula returns their middle point:

$$
\text{m}\left(p,q\right) = \nu \left(q-p\right) + p
$$

We now can:

- Find the middle point of $q$ and $p$, which is relative to the same edge but run in the opposite sense:

$$
\text{m}\left(q,p\right) = \nu \left(p-q\right) + q
$$

- Check that the middle point of $0$ and $1$ is indeed $\nu$:

$$
\text{m}\left(0,1\right) = \nu \left(1-0\right) + 0 = \nu \cdot 1 + 0 = \nu
$$

- Find the middle point of $1$ and $0$:

$$
\text{m}\left(1,0\right) = \nu \left(0-1\right) + 1 = \nu \cdot \left(-1\right) + 1 = 1 - \nu
$$

- Manipulate the formula to get

$$
\text{m}\left(p,q\right) = \nu \left(q-p\right) + p = \nu q - \nu p + p = \left(1-\nu \right) p + \nu q
$$

which looks suspiciously like the linear interpolation formula $\left(1-t \right) p + t q$, with $\nu$ in place of $t$. But not only isn't $\nu$ between $0$ and $1$: it's not even on the real line!

- Use the formula to deduce the position of all the vertices of a tiling after one round of deflation:



<p align="center">
  <img src="/Pictures/Post_2/Deflation_From_Midpoint.jpg" alt="Deflation Coordinates"/>
  <p class="post-meta" align="center">Vertices of the Deflation Diagram. The middle points are obtained by applying the formula to their parent edge's endpoints</p>
</p>

and we could go on forever, applying the formula to get the positions of the vertices that appear after further deflations.

Let me call your attention to the fact that although this is an important step towards solving the issue behind question #1, we're not quite there yet: yes, we're constructing middle points of arbitrary edges, but for the moment we aren't doing so by only using the integer coordinates of their endpoints on some basis.

In order to get there, we need to impose that whatever coordinate system we use, there must be two operations on it that work *exactly* like the complex sum and product would work on the points represented by some coordinates. This requirement is good for us, because it's the recipe by which we'll be able to cook the two operations as needed.

<h2>4. A Coordinate System for the Square-Triangle Grid</h2>

In the picture that depicts the vertices of the deflation diagram, you can notice that everything is built using only four elementary points, beyond $0$. They are $1$, $\nu$, $i$, and $\tau$. Every other point is obtained by addition or multiplication of those four. This sounds like a good candidate for a basis, doesn't it? Sadly, it can't be one: the four vectors are actually dependent[^6], since $\tau = 1 + i - \nu$.

Mindful of what we did when we found the collection $\left\\{1, \zeta, \zeta^2 \right\\}$ to not be independent in Section 1, you might ask if we should just leave $\tau$ out of the picture and take $\left\\{1, i, \nu \right\\}$ as our basis. These vectors are indeed independent (nice!), but regretfully they don't allow us to reach all the points in the deflation diagram. This is because the grid made of all the possible combinations of $1$, $i$ and $\nu$ is closed under addition but not under multiplication[^7]. In fact, there is no way to add $1$, $i$ and $\nu$ together and obtain $i\nu$, which is precisely the product of $i$ and $\nu$.

To be able to reach all points in the square-triangle grid, we need to add $i\nu$ to the collection. Luckily, that is already enough and it turns out that $\left\\{1, i, \nu, i\nu \right\\}$ is indeed a basis for the smallest *regular* grid that *contains any possible vertex* in our square-triangular grid, no matter how late it appears in the deflation process! We did it, we found our integer coordinates.

<p align="center">
  <img src="/Pictures/Post_2/NI_Basis.svg" height=400px alt="NI Basis"/>
  <p class="post-meta" align="center">The point of coordinates $(-1,1,3,-1)$ on the basis $\left\{1, i, \nu, i\nu \right\}$ </p>
</p>

This four-dimensional regular grid in the plane is, for mathematicians, "$\mathbb{Z}\left[\zeta_{12}\right]$, the ring of integers of the cyclotomic field $\mathbb{Q}\left(\zeta_{12}\right)$, where $\zeta_{12}$ is the twelfth root of unity". It's one of the structures studied by a branch of mathematics called number theory. For simplicity, I refer to its elements as "dodecs" -- short for "dodecagonal numbers" -- in the code implementation. I'll refer to them by the same name here, as long as you keep in mind that their actual name in maths is the former.

In the code, dodecs are implemented as a class made of four integers: the coordinates with respect to the basis $\left\\{1, i, \nu, i\nu \right\\}$. The class allows you to add and multiply dodecs, as well as compute their position. Since performing operations between them doesn't generate numerical errors, there's no problem in hashing them. In fact, vertices in the TileMesh class are kept in a hashmap whose keys are dodecs. This allows us to get an existing vertex in the mesh very quickly by providing its integer coordinates.

Naturally, as seen in Section 1, we could express dodecs in many different bases. The code implementation provides conversions of the coordinates to a handful of meaningful bases other than $\left\\{1, i, \nu, i\nu \right\\}$.

I'll use one of these to show how to build the sum and product operations on the coordinates, for two reasons: it's a basis that is more commonly used when working with $\mathbb{Z}\left[\zeta_{12}\right]$ and the calculations are a little simpler than when using the other one.

This basis is $\left\\{1, \varphi, \varphi^2, \varphi^3 \right\\}$ and this picture shows how you can obtain $\nu$ with it:

$$
\nu = 1 - \varphi^2 + \varphi^3
$$

<p align="center">
  <img src="/Pictures/Post_2/N_from_P.svg" height=400px alt="Nu from Phi"/>
  <p class="post-meta" align="center">$\nu$ over the basis $\left\{ 1, \varphi, \varphi^2, \varphi^3 \right\}$ </p>
</p>

It also shows that, in this basis, $i = \varphi^3$. With a little calculation, you can find that $i\nu = \varphi - 1$.

Using this basis, the coordinates are added like this:

$$

\left(x_0,y_0,z_0,w_0\right) + \left(x_1,y_1,z_1,w_1\right) = \left(x_0+x_1,y_0+y_1,z_0+z_1,w_0+w_1\right)

$$

and multiplied like so:

$$

\left(x_0,y_0,z_0,w_0\right) \cdot \left(x_1,y_1,z_1,w_1\right) =

\left(
\begin{array}{c}
x_0 x_1 - y_0 w_1 - z_0 z_1 - w_0 y_1 - w_0 w_1 \\
x_0 y_1 + y_0 x_1 - z_0 w_1 - w_0 z_1 \\
x_0 z_1 + y_0 y_1 + z_0 x_1 + y_0 w_1 + z_0 z_1 + w_0 y_1 \\
x_0 w_1 + y_0 z_1 + z_0 y_1 + w_0 x_1 + z_0 w_1 + w_0 z_1
\end{array}
\right)

$$

<details>
<summary>$\boxed{\text{Danger, Algebra Inside}} - \text{How are the formulas obtained?}$</summary>
<br>
<hr>

We define the sum to work like the complex sum operates on the corresponding points on the complex plane:

$$
\left(x_0,y_0,z_0,w_0\right) + \left(x_1,y_1,z_1,w_1\right) \leftrightarrow
\left( x_0 + y_0 \varphi + z_0 \varphi^2 + w_0 \varphi^3 \right) + \left( x_1 + y_1 \varphi + z_1 \varphi^2 + w_1 \varphi^3 \right)
$$

We can rearrange the terms and factor the common ones:

$$
\begin{array}{rl}
& x_0 + y_0 \varphi + z_0 \varphi^2 + w_0 \varphi^3 + x_1 + y_1 \varphi + z_1 \varphi^2 + w_1 \varphi^3 \\
= & \left(x_0 + x_1\right) + \left(y_0 + y_1\right) \varphi + \left(z_0 + z_1\right) \varphi^2 + \left(w_0 + w_1\right) \varphi^3
\end{array}
$$

Reading the coefficients of the basis vectors, we find the coordinates:

$$
\left(x_0+x_1,y_0+y_1,z_0+z_1,w_0+w_1\right)
$$

The producted is computed similarly:

$$
\left(x_0,y_0,z_0,w_0\right) \cdot \left(x_1,y_1,z_1,w_1\right) \leftrightarrow
\left( x_0 + y_0 \varphi + z_0 \varphi^2 + w_0 \varphi^3 \right) \cdot \left( x_1 + y_1 \varphi + z_1 \varphi^2 + w_1 \varphi^3 \right)
$$

This time around distribute the product over the sum:

$$
\begin{array}{rcl}
  &        x_0 x_1 & 1 \\
+ & \left( x_0 y_1 + y_0 x_1 \right) & \varphi \\
+ & \left( x_0 z_1 + y_0 y_1 + z_0 x_1 \right) & \varphi^2 \\
+ & \left( x_0 w_1 + y_0 z_1 + z_0 y_1 + w_0 x_1 \right) & \varphi^3 \\
+ & \left( y_0 w_1 + z_0 z_1 + w_0 y_1 \right) & \varphi^4 \\
+ & \left( z_0 w_1 + w_0 z_1 \right) & \varphi^5 \\
+ &        w_0 w_1 & \varphi^6 \\
\end{array}
$$

A peculiarity of the number $\varphi$ is that $\varphi^4 = \varphi^2 - 1$. This lets us lower the degree of some terms, by expressing $\varphi^4$, $\varphi^5$ and $\varphi^6$ with the basis $\left\{1, \varphi, \varphi^2, \varphi^3 \right\}$:

$$
\begin{array}{rcl}
\varphi^4 & = & \varphi^2 - 1 \\
\varphi^5 = \varphi \cdot \varphi^4 & = & \varphi^3 - \varphi \\
\varphi^6 = \varphi^2 \cdot \varphi^4 & = & \varphi^4 - \varphi^2 = \left(\varphi^2 - 1\right) - \varphi^2 = -1
\end{array}
$$

Substituting in the previous expression,

$$
\begin{array}{rcl}
  &        x_0 x_1 - \left( y_0 w_1 + z_0 z_1 + w_0 y_1 \right) - w_0 w_1 & 1\\
+ & \left( x_0 y_1 + y_0 x_1 \right) - \left( z_0 w_1 + w_0 z_1 \right) & \varphi \\
+ & \left( x_0 z_1 + y_0 y_1 + z_0 x_1 \right) + \left( y_0 w_1 + z_0 z_1 + w_0 y_1 \right) & \varphi^2 \\
+ & \left( x_0 w_1 + y_0 z_1 + z_0 y_1 + w_0 x_1 \right) + \left( z_0 w_1 + w_0 z_1 \right) & \varphi^3 \\
\end{array}
$$

Which says that the coordinates of the product are

$$
\left(
\begin{array}{c}
x_0 x_1 - y_0 w_1 - z_0 z_1 - w_0 y_1 - w_0 w_1 \\
x_0 y_1 + y_0 x_1 - z_0 w_1 - w_0 z_1 \\
x_0 z_1 + y_0 y_1 + z_0 x_1 + y_0 w_1 + z_0 z_1 + w_0 y_1 \\
x_0 w_1 + y_0 z_1 + z_0 y_1 + w_0 x_1 + z_0 w_1 + w_0 z_1
\end{array}
\right)
$$

<hr>
</details>

<p align="center">
  <img src="/Pictures/Post_2/Deflation_Coordinates.jpg" alt="Deflation Coordinates"/>
  <p class="post-meta" align="center">Vertex Coordinates of the Deflation Diagram over the basis $\left\{ 1, \varphi, \varphi^2, \varphi^3 \right\}$</p>
</p>

This completes the search for integer coordinates to assign to the vertices of the mesh. It took a while: we went from understanding that coordinates are numbers that rely on an underlying list of generating vectors called a basis, then we understood how those coordinates allowed us to pinpoint vertex positions with extreme accuracy, and finally we saw how different coordinates could be combined to generate new points in a geometrically meaningful way.

Armed with this knowledge, we will be able to implement a precise and efficient mesh, on which we can also do custom logic that is empowered by the two coordinate operations.

___

<h3>Notes and References:</h3>

[^1]: Nope, slabs don't count. They are full blocks with a weirder shape, rather than the elementary component of the world. That title goes to blocks - the full kind.  

[^vector]: I'll sometimes use the term 'vector' improperly in this post for a simple reason: people who didn't study maths at university are used to calling objects with multiple coordinates 'vectors'. There's no doubt that any mathematician who happens to read this page is going to badly cringe every single time they see the word 'vector' used in this context. If you're wondering why, it's because the spaces treated in this post are not vector spaces, but $\mathbb{Z}$-modules. They share similarities with vector spaces, but they are way less straightforward.

[^2]: If you're interested, it has to do with the fact that if you have two complex numbers that define a frame of reference - which means that they are not zero and they point in different directions - you can always divide both by one of the two. This has the effect of rotating and scaling your frame of reference uniformly. But now one of your vectors is just the (complex) number $1$!

[^3]: You might be tempted to say: "But of course they aren't independent, they are three but the plane is bi-dimensional. There just isn't enough room". If that's the case, hold that thought: we'll see in a little bit that even though in some contexts you'd be right, we're working with something different here. The key is to always remember that we need to work with *integer* numbers.

[^5]: Here you can spot one big difference between *actual* vector spaces and these grids, which are objects called free $\mathbb{Z}$-modules. In vector spaces of dimension $n$, as soon as you have $n$ independent vectors, they form a basis: you can reach all the vector space. On the triangular grid however, sometimes two independent vectors are enough and sometimes they are not.

[^6]: Remember that we mean *dependent over the integers*: which stands for being able to express a vector as a combination of the others in the collection *with integer coefficients*.

[^7]: Not being "closed under multiplication" means that we can find two points on the grid such that their product is a point that doesn't lie on the grid: it *escaped* via multiplication, because the grid wasn't "closed".